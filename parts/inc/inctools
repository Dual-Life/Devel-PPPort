# These are tools that must be included in ppport.h.  It doesn't work if given
# a .pl suffix

sub format_version
{
  # Given an input version that is acceptable to parse_version(), return a
  # string of the standard representation of it.

  my($r,$v,$s) = parse_version(shift);

  if ($r < 5 || ($r == 5 && $v < 6)) {
    my $ver = sprintf "%d.%03d", $r, $v;
    $s > 0 and $ver .= sprintf "_%02d", $s;

    return $ver;
  }

  return sprintf "%d.%d.%d", $r, $v, $s;
}

sub parse_version
{
  my $ver = shift;

  if ($ver =~ /^(\d+)\.(\d+)\.(\d+)$/) {
    return ($1, $2, $3);
  }
  elsif ($ver !~ /^\d+\.\d{3}(?:_\d{2})?$/) {
    die "cannot parse version '$ver'\n";
  }

  $ver =~ s/_//g;
  $ver =~ s/$/000000/;

  my($r,$v,$s) = $ver =~ /(\d+)\.(\d{3})(\d{3})/;

  $v = int $v;
  $s = int $s;

  if ($r < 5 || ($r == 5 && $v < 6)) {
    if ($s % 10) {
      die "cannot parse version '$ver'\n";
    }
    $s /= 10;
  }

  return ($r, $v, $s);
}

sub dictionary_order($$)    # Sort caselessly, ignoring punct
{
    my ($lc_a, $lc_b);
    my ($squeezed_a, $squeezed_b);
    my ($valid_a, $valid_b);    # Meaning valid for all releases

    # On early perls, the implicit pass by reference doesn't work, so we have
    # to use the globals to initialize.
    if ("$]" < "5.006" ) {
        $valid_a = $a; $valid_b = $b;
    }
    else {
        ($valid_a, $valid_b) = @_;
    }

    $lc_a = lc $valid_a;
    $lc_b = lc $valid_b;

    $squeezed_a = $lc_a;
    $squeezed_a =~ s/[\W_]//g;   # No punct, including no underscore
    $squeezed_b = $lc_b;
    $squeezed_b =~ s/[\W_]//g;

    return( $squeezed_a cmp $squeezed_b
         or       $lc_a cmp $lc_b
         or    $valid_a cmp $valid_b);
}

1;
